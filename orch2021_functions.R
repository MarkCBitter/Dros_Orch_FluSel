###Functions to analyze orchard 2021 E cage data
###Many of these functions are orginially generated by, or modified from, functions written by Sharon Greenblum


###Get pairwise fst matrix from allele frequency matrix
###Function written by S. Greenblum
Fst.mat = function (x) 
{
    if (is.data.frame(x)) 
        x <- as.matrix(x)
    if (!(is.numeric(x) || is.logical(x))) 
        stop("'x' must be numeric")
    ncy <- ncx <- ncol(x)
    r <- matrix(0, nrow = ncx, ncol = ncy)
    for (i in seq_len(ncx)) {
        for (j in seq_len(i)) {
            x2 <- x[, i]
            y2 <- x[, j]
            r[i, j] <- mean(Fst(x2, y2), na.rm = T)
        }
    }
    r <- r + t(r) - diag(diag(r))
    rownames(r) <- colnames(x)
    colnames(r) <- colnames(x)
    r
}
get_af_shifts = function (afmat, samps, cage_set = NULL, comparisons) 
{
    df.shifts = do.call(cbind, lapply(comparisons, function(cc) {
        tt = rev(chop(cc, "_", 1:2))
        if (is.null(cage_set)) {
            cage_set = unique(samps$cage)
        }
        cageMask = samps$cage %in% cage_set
        t1Mask = cageMask & samps$tpt == tt[1]
        if (sum(t1Mask) > 1) {
            af1 = rowMeans(afmat[, t1Mask])
        }
        else {
            af1 = afmat[, t1Mask]
        }
        t2Mask = cageMask & samps$tpt == tt[2]
        if (sum(t2Mask) > 1) {
            af2 = rowMeans(afmat[, t2Mask])
        }
        else {
            af2 = afmat[, t2Mask]
        }
        ss = data.frame(dAF = af2 - af1) %>% rename_all(.funs = function(x) {
            paste0("dAF.", cc)
        })
        return(ss)
    }))
    return(df.shifts)
}

#############
#############


###Fit a glm to allele frequency data using time point as a continuous numeric variable.
###Function modified from a function generated by S. Greenblum
##afMatrix is a numeric allele frequency matrix (columns correspond to samples, rows to sites)
##rdMatrix is a numeric matrix of estimated effective coverage fore each site (rows x col's correspond to afMatrix)
##sampleData is a dataframe whereby each row contains sample data for the corresponding column of the afMatrix and rdMatrix


fit_GLM_ContinuousTime = function (afMatrix, rdMatrix, sampleData, vec, model.vars, poolCt = 100, 
    ncores) 
{
    registerDoMC(ncores)
    df = as.data.frame(sampleData[, colnames(sampleData) %in% 
        model.vars])
    colnames(df) <- model.vars
    formulaString = paste0(colnames(df))
    formulaString = paste0("cts ~ ", formulaString)
    cat("Model Formula is: \n", formulaString, "\n")
    Neff = calc_Neff(rdMatrix, poolCt)
    do.call(rbind, mclapply(1:nrow(afMatrix), function(ix) {
        if (ix%%10000 == 0) {
            cat("working on site ", ix, "\n")
        }
        cts = cbind(t(round(Neff[ix, ] * afMatrix[ix, ])), t(round(Neff[ix, 
            ] * (1 - afMatrix[ix, ]))))
        df$cts = cts
        df = as.data.frame(df)
        model = glm(formulaString, family = "quasibinomial", 
            data = df)
        cp = summary(model)$coefficients[-1, c(1, 4), drop = FALSE]
        results = c(cp[, 1], cp[, 2])
        names(results) = c(paste0("coef.", vec[1], "_", vec[length(vec)]), 
            paste0("p.", vec[1], "_", vec[length(vec)]))
        return(results)
    }, mc.cores = ncores))
}

############
############


##Get allele frequency shifts for a given set of time point comparisons
##using same allele frequency matrix and sample information dataframe as fit_ContinuousTime_GLM function
##Function written by S. Greenblum

get_af_shifts = function (afmat, samps, cage_set = NULL, comparisons) 
{
    df.shifts = do.call(cbind, lapply(comparisons, function(cc) {
        tt = rev(chop(cc, "_", 1:2))
        if (is.null(cage_set)) {
            cage_set = unique(samps$cage)
        }
        cageMask = samps$cage %in% cage_set
        t1Mask = cageMask & samps$tpt == tt[1]
        if (sum(t1Mask) > 1) {
            af1 = rowMeans(afmat[, t1Mask])
        }
        else {
            af1 = afmat[, t1Mask]
        }
        t2Mask = cageMask & samps$tpt == tt[2]
        if (sum(t2Mask) > 1) {
            af2 = rowMeans(afmat[, t2Mask])
        }
        else {
            af2 = afmat[, t2Mask]
        }
        ss = data.frame(dAF = af2 - af1) %>% rename_all(.funs = function(x) {
            paste0("dAF.", cc)
        })
        return(ss)
    }))
    return(df.shifts)
}

##########
##########


###Get FDR corrected pvalues from df.glm object (output of fit_ContinousTime_GLM function)
###Modified function from S. Greenblum
get_glm_FDR.V2 = function (df.glm) 
{
    pvals = df.glm %>% dplyr::select(contains("p."))
    pval.corr = data.frame(nrow = nrow(pvals))
    for (i in 1:ncol(pvals)) {
        pval.vec = p.adjust(pvals[, i], method = "BH")
        pval.corr = cbind(pval.corr, pval.vec)
    }
    FDR = as.data.frame(pval.corr[, -1])
    colnames(FDR) = colnames(pvals)
    FDR = as.matrix(FDR)
    return(FDR)
    }


#########
########


###Get significant sites from GLM file
###Written by S. Greenblum

get_sig_sites = function (df.glm, comparisons, FDR, afShifts, fdrThreshs, esThreshs) 
{
    pSig = Reduce("+", lapply(1:length(fdrThreshs), function(ii) {
        (0 + (FDR <= fdrThreshs[ii] & abs(afShifts) >= esThreshs[ii]))
    }))
    do.call(rbind, lapply(comparisons, function(cc) {
        cc.ix = match(cc, comparisons)
        df.glm %>% mutate(ix = 1:nrow(df.glm)) %>% rename(coef.div = paste0("coef.", 
            cc), p.div = paste0("p.", cc)) %>% dplyr::select(ix, 
            chrom, pos, coef.div, p.div) %>% mutate(sigLevel = pSig[, 
            cc.ix], FDR = FDR[, cc.ix], afShift = afShifts[, 
            cc.ix], comparison = cc) %>% filter(sigLevel > 0, 
            !is.na(p.div))
    })) %>% mutate(comparison = factor(comparison, comparisons))
}


##########
##########


###Get a matched snp using the chrom/pos of a target snp, vector of significant sites to exclude (snps.c), and baseline data with
##inversion status and recombination rate info

get.MatchedSNP.DfSig = function (x, snps.c, base.data) 
{
    chr = x$chrom
    p = x$pos
    min.freq = x$af.base.mean - 0.025
    max.freq = x$af.base.mean + 0.025
    min.recomb = x$RECOM - 0.5
    max.recomb = x$RECOM + 0.5
    p.matched = as.data.frame(base.data %>% mutate(snp = paste0(CHROM, POS)) %>%
                                  filter(CHROM == chr & POS != p & between(af.base.mean, min.freq, max.freq)) %>%  #filter on chrom and starting freq.
                                  filter(Inv == x$Inv & between(RECOM, min.recomb, max.recomb)) %>% ##filter on inv status and recomb rate
                                  filter(POS > p + 10000  | POS < p - 10000) %>% #filter on position and ensure 
                                  filter(!snp %in% snps.c)) %>% #filter out snps in the df.sig file
        sample_n(1) %>% rename(pos.matched = POS)
    d.new = cbind(x, p.matched %>% dplyr::select(pos.matched))
    return(d.new)
}

###


####Get phased allele frequency shifts at target sites and shifts at matched controls within each weekly/consecutive time point interval.
###Input is the file outputed from the get_sig_sites function, with an added column denoting the matched control snp for each test snp

get.WeeklyShifts = function (df.Sig.Matched, RData, weekly.shifts) 
{
    load(RData)
    df = df.Sig.Matched %>% mutate(sign.shift = sign(afShift), 
        phased.afShift = abs(afShift))
    af.shifts = read.csv(weekly.shifts)
    af.shifts = cbind(sites, af.shifts)
    af.shifts.target = af.shifts
    colnames(af.shifts.target) = paste(colnames(af.shifts), "target", 
        sep = ".")
    colnames(af.shifts.target)[1:2] = c("chrom", "pos")
    af.shifts.matched = af.shifts
    colnames(af.shifts.matched) = paste(colnames(af.shifts), 
        "matched", sep = ".")
    colnames(af.shifts.matched)[1:2] = c("chrom", "pos")
    df.target = as.data.frame(left_join((df %>% dplyr::select(chrom, 
        pos)), af.shifts.target) %>% dplyr::select(-chrom, -pos))
    df.matched = as.data.frame(left_join((df %>% dplyr::select(chrom, 
        pos.matched) %>% rename(pos = pos.matched)), af.shifts.matched) %>% 
        dplyr::select(-chrom, -pos))
    signs = df$sign.shift
    df.target.phased = data.frame(nrow = nrow(df))
    for (cols in 1:ncol(df.target)) {
        col = df.target[, cols]
        col.new = signs * as.numeric(col)
        df.target.phased = cbind(df.target.phased, col.new)
    }
    df.target.phased = as.data.frame(df.target.phased[, -1])
    colnames(df.target.phased) = colnames(df.target)
    df.matched.phased = data.frame(nrow = nrow(df))
    for (cols in 1:ncol(df.matched)) {
        col = df.matched[, cols]
        col.new = 1 * col
        df.matched.phased = cbind(df.matched.phased, col.new)
    }
    df.matched.phased = as.data.frame(df.matched.phased[, -1])
    colnames(df.matched.phased) = colnames(df.matched)
    df.shifts = cbind(df, df.target.phased, df.matched.phased)
    return(df.shifts)
}

###########
##########



###Get shifts for any defined segement (next.segs)
###Input is the file outputed from the get_sig_sites function, with an added column denoting the matched control snp for each test snp
get.NextSegShifts.EcolPhasesLOA = function (df.sig.matched, RData, Comp, next.segs) 
{
    load(RData)
    df = df.sig.matched %>% filter(comparison == Comp) %>% mutate(sign.shift = sign(afShift), 
        phased.afShift = abs(afShift))
    af.shifts = get_af_shifts(afmat.lo, samps.lo, cage_set = NULL, 
        next.segs)
    af.shifts = cbind(sites, af.shifts)
    af.shifts.target = af.shifts
    colnames(af.shifts.target) = paste(colnames(af.shifts), "target", 
        sep = ".")
    colnames(af.shifts.target)[1:2] = c("chrom", "pos")
    af.shifts.matched = af.shifts
    colnames(af.shifts.matched) = paste(colnames(af.shifts), 
        "matched", sep = ".")
    colnames(af.shifts.matched)[1:2] = c("chrom", "pos")
    df.target = left_join((df %>% dplyr::select(chrom, pos)), 
        af.shifts.target) %>% dplyr::select(-chrom, -pos)
    signs = df$sign.shift
    df.target.phased = data.frame(nrow = nrow(df))
    for (cols in 1:ncol(df.target)) {
        col = df.target[, cols]
        col.new = signs * col
        df.target.phased = cbind(df.target.phased, col.new)
    }
    df.target.phased = as.data.frame(df.target.phased[, -1])
    colnames(df.target.phased) = colnames(df.target)
    df.matched = df %>% dplyr::select(chrom, pos.matched) %>% 
        rename(pos = pos.matched)
    df.matched = left_join(df.matched, af.shifts.matched) %>% 
        dplyr::select(-chrom, -pos)
    df.shifts = cbind(df, df.target.phased, df.matched)
    return(df.shifts)
}

##########
#########


###Another iteration of getting shifts from the sig sites dataframe - used in Resolving Tempo
get.NextSegShifts.Final = function (df.sig.matched, RData, RData_LOO, Comp, next.segs) 
{
    load(RData)
    df = df.sig.matched %>% filter(comparison == Comp) %>% mutate(sign.shift = sign(afShift), 
        phased.afShift = abs(afShift))
    af.shifts = get_af_shifts(afmat.lo, samps.lo, cage_set = NULL, 
        next.segs)
    af.shifts = cbind(sites, af.shifts)
    af.shifts.target = af.shifts
    colnames(af.shifts.target) = paste(colnames(af.shifts), "target", 
        sep = ".")
    colnames(af.shifts.target)[1:2] = c("chrom", "pos")
    load(RData_LOO)
    af.shifts.matched = get_af_shifts(afmat, samps, cage_set = NULL, 
        next.segs)
    af.shifts.matched = cbind(sites, af.shifts.matched)
    colnames(af.shifts.matched) = paste(colnames(af.shifts), 
        "matched", sep = ".")
    colnames(af.shifts.matched)[1:2] = c("chrom", "pos")
    df.target = left_join((df %>% dplyr::select(chrom, pos)), 
        af.shifts.target) %>% dplyr::select(-chrom, -pos)
    signs = df$sign.shift
    df.target.phased = data.frame(nrow = nrow(df))
    for (cols in 1:ncol(df.target)) {
        col = df.target[, cols]
        col.new = signs * col
        df.target.phased = cbind(df.target.phased, col.new)
    }
    df.target.phased = as.data.frame(df.target.phased[, -1])
    colnames(df.target.phased) = colnames(df.target)
    df.matched = left_join((df %>% dplyr::select(chrom, pos.matched) %>% 
            rename(pos = pos.matched)), af.shifts.matched) %>% 
            dplyr::select(-chrom, -pos)
        df.matched.phased = data.frame(nrow = nrow(df))
        for (cols in 1:ncol(df.matched)) {
            col = df.matched[, cols]
            col.new = 1 * col
            df.matched.phased = cbind(df.matched.phased, col.new)
        }
        df.matched.phased = as.data.frame(df.matched.phased[, 
            -1])
        colnames(df.matched.phased) = colnames(df.matched)
    df.shifts = cbind(df, df.target.phased, df.matched.phased)
    return(df.shifts)
}

#########
#########


###Get statistics for matched vs. target site allele frequency shifts
###Takes in output of get.Weekly.Shifts or get.NextSegShifts.EcolPhasesLOA
get.shift.stats = function (df.shifts) 
{
    comps = as.character(unique(df.shifts$comparison))
    df.stat.meta = data.frame()
    for (comp in comps) {
        df.c = df.shifts %>% filter(comparison == comp)
        segs = grep(".target", names(df.c), value = TRUE)
        for (i in (1:length(segs))) {
            segs[i] = strsplit(segs[i], "[.]")[[1]][2]
        }
        for (seg in segs) {
            df.stat = data.frame()
            ID.Seg = comp
            Test.Seg = seg
            matched.vec = df.c %>% dplyr::select(paste0("dAF.", 
                seg, ".matched"))
            matched.vec = matched.vec[, 1]
            median.matched = median(matched.vec)
            target.vec = df.c %>% dplyr::select(paste0("dAF.", 
                seg, ".target"))
            target.vec = target.vec[, 1]
            median.target = median(target.vec)
            if (length(target.vec) > 10) {
                pvalue = t.test(target.vec, matched.vec)$p.value
            }
            else {
                pvalue = NA
            }
            df.stat = cbind(ID.Seg, Test.Seg, median.matched, 
                median.target, pvalue)
            df.stat.meta = rbind(df.stat.meta, df.stat)
        }
        df.stat.meta = rbind(df.stat.meta, df.stat)
    }
    return(df.stat.meta)
}

#######
#######



